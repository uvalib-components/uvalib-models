<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../polymerfire/firebase-document.html">
<link rel="import" href="../app-storage/app-indexeddb-mirror/app-indexeddb-mirror.html">
<link rel="import" href="firebase-app.html">

<!--
`uvalib-model-file`
data model for the files used for the Library site

@demo demo/file.html
-->

<dom-module id="uvalib-model-file">
  <template>
    <template is="dom-if" if="[[uuid]]">
      <firebase-document id="query" app-name="uvalibapi"
        path="[[_dbPath(uuid)]]"
        data="{{tmpData}}"></firebase-document>
      <app-indexeddb-mirror
          key="file-[[uuid]]"
          data="[[tmpData]]"
          persisted-data="{{data}}"></app-indexeddb-mirror>
    </template>
  </template>

  <script>
    Polymer({

      is: 'uvalib-model-file',
      properties: {
        uuid: {
          type: String,
          value: null
        },
        /**
         * The file
         *
         * @type Object
         */
        data: {
          type: Object,
          value: null,
          notify: true
        },
        rawData: {
          type: String,
          computed: '_toString(data)',
          notify: true
        },
        url: {
          type: String,
          computed: '_getURL(data,_webPsupport)',
          notify: true
        },
        _webPsupport: {
          type: Boolean,
          value: null
        }
      },
      _getURL: function(data,webP){
        if(data)
          return (data.webpSrc && webP)?
            data.webpSrc:
            (data.compSrc)?
              data.compSrc:
              data.origSrc;
        else {
          return null;
        }
      },
      _toString: function(data){
        return JSON.stringify(data);
      },
      _dbPath: function(uuid){
        return '/files/'+uuid;
      },
      /**
       * from: https://developers.google.com/speed/webp/faq
       * 'feature' can be one of 'lossy', 'lossless', 'alpha' or 'animation'.
       * 'callback(feature, result)' will be passed back the detection result (in an asynchronous way!)
       */
      _checkWebP: function(feature, callback){
        var kTestImages = {
            lossy: "UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",
            lossless: "UklGRhoAAABXRUJQVlA4TA0AAAAvAAAAEAcQERGIiP4HAA==",
            alpha: "UklGRkoAAABXRUJQVlA4WAoAAAAQAAAAAAAAAAAAQUxQSAwAAAARBxAR/Q9ERP8DAABWUDggGAAAABQBAJ0BKgEAAQAAAP4AAA3AAP7mtQAAAA==",
            animation: "UklGRlIAAABXRUJQVlA4WAoAAAASAAAAAAAAAAAAQU5JTQYAAAD/////AABBTk1GJgAAAAAAAAAAAAAAAAAAAGQAAABWUDhMDQAAAC8AAAAQBxAREYiI/gcA"
        };
        var img = new Image();
        img.onload = function () {
            var result = (img.width > 0) && (img.height > 0);
            callback(feature, result);
        };
        img.onerror = function () {
            callback(feature, false);
        };
        img.src = "data:image/webp;base64," + kTestImages[feature];
      }.bind(this),
      ready: function(){
        if (window.webPsupport == undefined)
          if (this._webPsupport == undefined) {
            this._checkWebP('lossless',function(feature,support){
              this._webPsupport = support;
              window.webPsupport = support;
              console.log('webp support: '+support);
            }.bind(this));
          } else {
            window.webPsupport = this._webPsupport;
            console.log('webp support: '+support);
          }
      }
    });
  </script>
</dom-module>
